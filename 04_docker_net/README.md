### Задание 1. Исследование сетей Docker на хосте

1. Определить, какие сети созданы в Docker по умолчанию на вашей машине.
	-`bridge`, `host`, `none` найдены
    ![](imgs/Pasted%20image%2020251130221802.png)
2. Для сети по умолчанию типа `bridge`:
    ![](imgs/Pasted%20image%2020251130221843.png)
    - **Подсеть:** 172.18.0.0/16
	- **Шлюз:** 172.18.0.1
	- **Назначение:** 
		- Логическая группировка связанных контейнеров приложения и систем мониторинга
		- Изолированное взаимодействие между компонентами мониторинга
3. Кратко описать назначение трех стандартных сетей:
    - `bridge`
    
     Сеть по умолчанию для контейнеров, контейнеры получают внутренние IP-адреса, для внешнего доступа нужен проброс портов 
     
    - `host`
    
    Контейнер использует сетевой стек хоста напрямую, между контейнером и хостом нет сетевой изоляции, полезно для высокопроизводительных приложений
    
    - `none`
    Полное отсутствие сетевых интерфейсов (кроме loopback), максимальная изоляция контейнера

### Задание 2. Публикация порта контейнера

1. Выбрать любой простой веб-сервис в контейнере:
	Был выбран готовый образ веб-сервера nginx
	
2. Запустить контейнер так, чтобы:
    
    - Внутри контейнера приложение слушает внутренний порт 80 или
    - На хосте этот сервис был доступен по порту 8080
    ![](imgs/Pasted%20image%2020251130221924.png)
1. Проверить, что веб-сервис доступен:
    
    - через браузер по адресу `http://localhost:<порт_хоста>`
    - или с помощью любого HTTP-клиента
    - ![](imgs/Pasted%20image%2020251130222026.png)
### Задание 3. Пользовательская bridge-сеть и взаимодействие по имени

1. Создать **пользовательскую мостовую сеть** (bridge):
    
    - указать осмысленное имя (например, `my-app-net`)
    - при необходимости можно задать свой диапазон адресов, но это не обязательно
    - ![](imgs/Pasted%20image%2020251130222705.png)
2. Поднять в этой сети **два контейнера**:
    
    - условный контейнер `db`:
        - внутри должен работать сервис, к которому можно подключиться по TCP
        - это может быть:
            
            - база данных (MySQL/PostgreSQL/Redis)
            - простой HTTP-сервер
            - любой другой сетевой сервис, с которым вы умеете взаимодействовать![](imgs/Pasted%20image%2020251130224909.png)
    - условный контейнер `web`:
        
        - контейнер-клиент, из которого можно обратиться к `db`
        - внутри должен быть установлен клиент/утилита, позволяющая выполнить запрос:
        - это может быть `curl`, `ping`, клиент к БД и т.п.
    
		![](imgs/Pasted%20image%2020251130225324.png)
        
3. Настроить взаимодействие:
    
    - контейнер `web` должен обращаться к сервису в `db` **по имени контейнера**, а не по IP-адресу
    - продемонстрировать успешный запрос:
        
        - например, ping по имени,
        - подключение к БД по имени хоста,
        - HTTP-запрос вида `http://db:порт`.
        - ![](imgs/Pasted%20image%2020251130230851.png)
		 ![](imgs/Pasted%20image%2020251130230952.png)
		 ![](imgs/Pasted%20image%2020251130231256.png)
4. Убедиться, что имя контейнера действительно используется как адрес, а не «случайный IP»:
    
    - в отчете явно указать имя контейнера
	    -![](imgs/Pasted%20image%2020251130231537.png)
    - при желании можно показать, что IP-адрес, отображаемый в настройках, отличается от имени и может измениться
	    ![](imgs/Pasted%20image%2020251130235231.png)

### Задание 4 Изоляция контейнера

1. Запустить третий контейнер, который **не подключен** к созданной пользовательской сети:
    
    - либо в сети по умолчанию (`bridge`)
    - либо вообще без сети (`none`)
	    ![](imgs/Pasted%20image%2020251201000940.png)
1. Попробовать из этого контейнера обратиться к сервису `db`:
    
    - по имени контейнера `db`
    - при желании по IP
2. Наблюдать, что доступ невозможен (ошибка разрешения имени/подключения).
		![](imgs/Pasted%20image%2020251201001042.png)
		![](imgs/Pasted%20image%2020251201001226.png)
